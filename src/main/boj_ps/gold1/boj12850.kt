package gold1

/*
산책시작 후 D분에는 정보과학관에 도착해야 한다
인접한 다른 건물로 이동하는데 1분이 걸린다.
D는 10억
사이클 가능...
DP
정보과학관에서 출발 -> 정보과학관에 도착
이거 왜 정답비율 85인것?
N이 10억번 돌아도 되나요...안될듯한데
"가능한 경로의 수"
t 1
정보-전산
정보-미래

-> 2
t 2
정보-전산-정보
정보-전산-신양
정보-전산-미래

정보-미래-정보
정보-미래-한경
정보-미래-신양
정보-미래-전산

-> 7
t 3
정보-전산-정보-전산
정보-전산-정보-미래

정보-전산-신양-전산
정보-전산-신양-미래
정보-전산-신양-진리
정보-전산-신양-한경

정보-전산-미래

정보-미래-정보
정보-미래-한경
정보-미래-신양
정보-미래-전산
...


정보 -> 전산/미래
전산 -> 정보/미래/신양
미래 -> 정보/전산/신양/한경
신양 -> 전산/미래/진리/한경
한경 -> 미래/신양/진리/형남
진리 -> 신양/한경/학생
학생 -> 진리/형남
형남 -> 학생/한경

int[8]짜리 배열만들어서
각 초마다 더해주기?
n으로 떨어지면 시초날듯

정보->전산으로 가는 가짓수 1
정보->미래로 가는 가짓수 1

행렬이었네요
해산~

* */

fun main() = with(System.`in`.bufferedReader()) {
    var N = readln().toInt()
    val MOD = 1000000007

    // 정전미신한진학형
    var dp = LongArray(8)

    // 1초일 때 dp배열 초기화
    dp[1] = 1
    dp[2] = 1

    for (i in 2..N) {
        var dp0 = dp[0]
        var dp1 = dp[1]
        var dp2 = dp[2]
        var dp3 = dp[3]
        var dp4 = dp[4]
        var dp5 = dp[5]
        var dp6 = dp[6]
        var dp7 = dp[7]

        // 정보
        dp[0] = (dp[0] + dp1 + dp2) % MOD
        // 전산
        dp[1] = (dp[1] + dp0 + dp2 + dp3) % MOD
        // 미래
        dp[2] = (dp[2] + dp0 + dp1 + dp3 + dp4) % MOD
        // 신양
        dp[3] = (dp[3] + dp1 + dp2 + dp4 + dp5) % MOD
        // 한경
        dp[4] = (dp[4] + dp2 + dp3 + dp5) % MOD
        // 진리
        dp[5] = (dp[5] + dp3 + dp4 + dp6) % MOD
        // 학생
        dp[6] = (dp[6] + dp5 + dp7) % MOD
        // 형남
        dp[7] = (dp[7] + dp4 + dp6) % MOD
    }

    println(dp[0])

}